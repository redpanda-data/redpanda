//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright 2022 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaAPISpec) DeepCopyInto(out *KafkaAPISpec) {
	*out = *in
	if in.Brokers != nil {
		in, out := &in.Brokers, &out.Brokers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(KafkaTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.SASL != nil {
		in, out := &in.SASL, &out.SASL
		*out = new(KafkaSASL)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaAPISpec.
func (in *KafkaAPISpec) DeepCopy() *KafkaAPISpec {
	if in == nil {
		return nil
	}
	out := new(KafkaAPISpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASL) DeepCopyInto(out *KafkaSASL) {
	*out = *in
	out.Password = in.Password
	out.OAUth = in.OAUth
	out.GSSAPIConfig = in.GSSAPIConfig
	out.AWSMskIam = in.AWSMskIam
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASL.
func (in *KafkaSASL) DeepCopy() *KafkaSASL {
	if in == nil {
		return nil
	}
	out := new(KafkaSASL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASLAWSMskIam) DeepCopyInto(out *KafkaSASLAWSMskIam) {
	*out = *in
	out.SecretKey = in.SecretKey
	out.SessionToken = in.SessionToken
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASLAWSMskIam.
func (in *KafkaSASLAWSMskIam) DeepCopy() *KafkaSASLAWSMskIam {
	if in == nil {
		return nil
	}
	out := new(KafkaSASLAWSMskIam)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASLGSSAPI) DeepCopyInto(out *KafkaSASLGSSAPI) {
	*out = *in
	out.Password = in.Password
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASLGSSAPI.
func (in *KafkaSASLGSSAPI) DeepCopy() *KafkaSASLGSSAPI {
	if in == nil {
		return nil
	}
	out := new(KafkaSASLGSSAPI)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASLOAuthBearer) DeepCopyInto(out *KafkaSASLOAuthBearer) {
	*out = *in
	out.Token = in.Token
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASLOAuthBearer.
func (in *KafkaSASLOAuthBearer) DeepCopy() *KafkaSASLOAuthBearer {
	if in == nil {
		return nil
	}
	out := new(KafkaSASLOAuthBearer)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTLS) DeepCopyInto(out *KafkaTLS) {
	*out = *in
	if in.CaCert != nil {
		in, out := &in.CaCert, &out.CaCert
		*out = new(SecretKeyRef)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(SecretKeyRef)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(SecretKeyRef)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTLS.
func (in *KafkaTLS) DeepCopy() *KafkaTLS {
	if in == nil {
		return nil
	}
	out := new(KafkaTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretKeyRef) DeepCopyInto(out *SecretKeyRef) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretKeyRef.
func (in *SecretKeyRef) DeepCopy() *SecretKeyRef {
	if in == nil {
		return nil
	}
	out := new(SecretKeyRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Topic) DeepCopyInto(out *Topic) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Topic.
func (in *Topic) DeepCopy() *Topic {
	if in == nil {
		return nil
	}
	out := new(Topic)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Topic) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicList) DeepCopyInto(out *TopicList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Topic, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicList.
func (in *TopicList) DeepCopy() *TopicList {
	if in == nil {
		return nil
	}
	out := new(TopicList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TopicList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicSpec) DeepCopyInto(out *TopicSpec) {
	*out = *in
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = new(int)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(int)
		**out = **in
	}
	if in.OverwriteTopicName != nil {
		in, out := &in.OverwriteTopicName, &out.OverwriteTopicName
		*out = new(string)
		**out = **in
	}
	if in.AdditionalConfig != nil {
		in, out := &in.AdditionalConfig, &out.AdditionalConfig
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KafkaAPISpec != nil {
		in, out := &in.KafkaAPISpec, &out.KafkaAPISpec
		*out = new(KafkaAPISpec)
		(*in).DeepCopyInto(*out)
	}
	if in.MetricsNamespace != nil {
		in, out := &in.MetricsNamespace, &out.MetricsNamespace
		*out = new(string)
		**out = **in
	}
	if in.SynchronizationInterval != nil {
		in, out := &in.SynchronizationInterval, &out.SynchronizationInterval
		*out = new(v1.Duration)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicSpec.
func (in *TopicSpec) DeepCopy() *TopicSpec {
	if in == nil {
		return nil
	}
	out := new(TopicSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicStatus) DeepCopyInto(out *TopicStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicStatus.
func (in *TopicStatus) DeepCopy() *TopicStatus {
	if in == nil {
		return nil
	}
	out := new(TopicStatus)
	in.DeepCopyInto(out)
	return out
}
