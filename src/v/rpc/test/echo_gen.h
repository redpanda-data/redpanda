// This file is autogenerated. Manual changes will be lost.
#pragma once

#include "finjector/hbadger.h"
#include "random/fast_prng.h"
#include "rpc/netbuf.h"
#include "rpc/parse_utils.h"
#include "rpc/service.h"
#include "rpc/transport.h"
#include "rpc/types.h"
#include "utils/string_switch.h"

// extra includes
#include "rpc/test/rpc_gen_types.h"
#include "seastarx.h"

#include <seastar/core/reactor.hh>
#include <seastar/core/scheduling.hh>
#include <seastar/core/shared_ptr.hh>
#include <seastar/core/sleep.hh>

#include <chrono>
#include <cstdint>
#include <functional>
#include <tuple>

namespace echo {

class echo_service : public rpc::service {
public:
    class failure_probes;

    echo_service(ss::scheduling_group sc, ss::smp_service_group ssg)
      : _sc(sc)
      , _ssg(ssg) {}

    echo_service(echo_service&& o) noexcept
      : _sc(std::move(o._sc))
      , _ssg(std::move(o._ssg))
      , _methods(std::move(o._methods)) {}

    echo_service& operator=(echo_service&& o) noexcept {
        if (this != &o) {
            this->~echo_service();
            new (this) echo_service(std::move(o));
        }
        return *this;
    }

    virtual ~echo_service() noexcept = default;

    ss::scheduling_group& get_scheduling_group() override { return _sc; }

    ss::smp_service_group& get_smp_service_group() override { return _ssg; }

    rpc::method* method_from_id(uint32_t idx) final {
        switch (idx) {
        case 1350179844:
            return &_methods[0];
        case 1296043586:
            return &_methods[1];
        case 881961103:
            return &_methods[2];
        default:
            return nullptr;
        }
    }
    /// \brief echo_req -> echo_resp
    virtual ss::future<rpc::netbuf>
    raw_prefix_echo(ss::input_stream<char>& in, rpc::streaming_context& ctx) {
        auto fapply = execution_helper<echo_req, echo_resp>();
        return fapply.exec(
          in,
          ctx,
          1350179844,
          [this](echo_req&& t, rpc::streaming_context& ctx)
            -> ss::future<echo_resp> {
              return prefix_echo(std::move(t), ctx);
          });
    }
    virtual ss::future<echo_resp>
    prefix_echo(echo_req&&, rpc::streaming_context&) {
        throw std::runtime_error("unimplemented method");
    }
    /// \brief echo_req -> echo_resp
    virtual ss::future<rpc::netbuf>
    raw_suffix_echo(ss::input_stream<char>& in, rpc::streaming_context& ctx) {
        auto fapply = execution_helper<echo_req, echo_resp>();
        return fapply.exec(
          in,
          ctx,
          1296043586,
          [this](echo_req&& t, rpc::streaming_context& ctx)
            -> ss::future<echo_resp> {
              return suffix_echo(std::move(t), ctx);
          });
    }
    virtual ss::future<echo_resp>
    suffix_echo(echo_req&&, rpc::streaming_context&) {
        throw std::runtime_error("unimplemented method");
    }
    /// \brief echo_req -> echo_resp
    virtual ss::future<rpc::netbuf>
    raw_sleep_5s(ss::input_stream<char>& in, rpc::streaming_context& ctx) {
        auto fapply = execution_helper<echo_req, echo_resp>();
        return fapply.exec(
          in,
          ctx,
          881961103,
          [this](echo_req&& t, rpc::streaming_context& ctx)
            -> ss::future<echo_resp> { return sleep_5s(std::move(t), ctx); });
    }
    virtual ss::future<echo_resp>
    sleep_5s(echo_req&&, rpc::streaming_context&) {
        throw std::runtime_error("unimplemented method");
    }

private:
    ss::scheduling_group _sc;
    ss::smp_service_group _ssg;
    std::array<rpc::method, 3> _methods{
      {rpc::method(
         [this](ss::input_stream<char>& in, rpc::streaming_context& ctx) {
             return raw_prefix_echo(in, ctx);
         }),
       rpc::method(
         [this](ss::input_stream<char>& in, rpc::streaming_context& ctx) {
             return raw_suffix_echo(in, ctx);
         }),
       rpc::method(
         [this](ss::input_stream<char>& in, rpc::streaming_context& ctx) {
             return raw_sleep_5s(in, ctx);
         })}};
};
class echo_client_protocol {
public:
    explicit echo_client_protocol(rpc::transport& t)
      : _transport(t) {}
    virtual inline ss::future<rpc::client_context<echo_resp>> prefix_echo(
      echo_req&& r, rpc::clock_type::time_point timeout = rpc::no_timeout) {
        return _transport.send_typed<echo_req, echo_resp>(
          std::move(r), 1350179844, timeout);
    }
    virtual inline ss::future<rpc::client_context<echo_resp>> suffix_echo(
      echo_req&& r, rpc::clock_type::time_point timeout = rpc::no_timeout) {
        return _transport.send_typed<echo_req, echo_resp>(
          std::move(r), 1296043586, timeout);
    }
    virtual inline ss::future<rpc::client_context<echo_resp>> sleep_5s(
      echo_req&& r, rpc::clock_type::time_point timeout = rpc::no_timeout) {
        return _transport.send_typed<echo_req, echo_resp>(
          std::move(r), 881961103, timeout);
    }

private:
    rpc::transport& _transport;
};

} // namespace echo
